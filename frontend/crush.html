<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
    <title>Love Crush</title>
    <link rel="stylesheet" href="global.css" />
    <style>
        :root {
            --acento-1: #ff6b9d;
            --acento-2: #ff8fab;
            --panel: rgba(26, 22, 37, 0.95);
            --texto: #ffe3ea;
            --atenuado: #b8a8c8;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(1200px 800px at 50% 20%, #1a1625 0%, #0f0f14 60%, #0a0a0d 100%);
            color: var(--texto);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial, "Noto Sans";
            touch-action: none;
        }

        #contenedor {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
        }

        canvas {
            display: block;
            border-radius: 18px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, .45), 0 2px 12px rgba(0, 0, 0, .6) inset;
            background: linear-gradient(135deg, #2a1f3d 0%, #1e1530 50%, #151122 100%);
            width: 100vw;
            height: 100vh;
        }

        .interfazUsuario {
            position: fixed;
            top: env(safe-area-inset-top);
            margin-top: 5%;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }

        .chip {
            margin-top: 20px;
            background: rgba(0, 0, 0, .35);
            border: 1px solid rgba(255, 255, 255, .15);
            border-radius: 999px;
            padding: 8px 14px;
            font-weight: 700;
            font-size: 14px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, .25);
        }

        .barra-superior {
            position: fixed;
            top: calc(env(safe-area-inset-top) + 8px);
            right: 8px;
            display: flex;
            gap: 8px;
            z-index: 11;
        }

        .pildora {
            background: rgba(0, 0, 0, .35);
            border: 1px solid rgba(255, 255, 255, .15);
            color: #fff;
            border-radius: 999px;
            padding: 8px 12px;
            font-weight: 800;
            font-size: 14px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, .25);
            cursor: pointer;
            pointer-events: all;
        }

        .controles {
            position: fixed;
            left: 0;
            right: 0;
            bottom: calc(env(safe-area-inset-bottom) + 12px);
            display: flex;
            justify-content: center;
            gap: 12px;
            padding: 0 12px;
            z-index: 10;
        }

        .btn {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px 24px;
            border-radius: 999px;
            border: none;
            background: linear-gradient(180deg, rgba(255, 255, 255, .12), rgba(255, 255, 255, .04));
            color: #fff;
            font-size: 16px;
            font-weight: 800;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            touch-action: manipulation;
            cursor: pointer;
            pointer-events: all;
        }

        .btn:active {
            transform: translateY(1px);
            filter: brightness(1.15);
        }

        .btn.acento {
            background: linear-gradient(90deg, var(--acento-1), var(--acento-2));
        }

        #superposicion {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(0, 0, 0, .5);
            z-index: 20;
        }

        #superposicion[hidden] {
            display: none;
        }

        .panel {
            background: var(--panel);
            border: 1px solid rgba(255, 255, 255, .12);
            padding: 22px 22px;
            border-radius: 16px;
            text-align: center;
            width: min(90vw, 380px);
            margin-bottom: env(safe-area-inset-bottom);
        }

        .panel h1 {
            margin: 0 0 10px 0;
            color: #ff7aa2;
            font-size: 26px;
        }

        .linea {
            margin: 6px 0;
            color: var(--atenuado);
        }

        .frase {
            margin: 12px 0 18px 0;
            font-style: italic;
            color: #ffe3ea;
        }

        .cta {
            background: linear-gradient(90deg, var(--acento-1), var(--acento-2));
            border: none;
            color: #fff;
            padding: 12px 16px;
            border-radius: 999px;
            font-weight: 800;
            cursor: pointer;
        }

        #pantallaInicio {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(0, 0, 0, .85);
            z-index: 30;
        }

        #pantallaInicio[hidden] {
            display: none;
        }

        .panel-inicio {
            background: var(--panel);
            border: 1px solid rgba(255, 255, 255, .12);
            padding: 30px 25px;
            border-radius: 16px;
            text-align: center;
            width: min(90vw, 380px);
            max-height: 80vh;
            overflow-y: auto;
        }

        .panel-inicio h1 {
            margin: 0 0 15px 0;
            color: #ff7aa2;
            font-size: 28px;
        }

        .instrucciones {
            margin: 15px 0 20px 0;
            text-align: left;
            color: #ffe3ea;
            font-size: 13px;
            line-height: 1.4;
        }

        .instrucciones li {
            margin-bottom: 6px;
        }

        .mensaje-temporal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff4d6d;
            border-radius: 12px;
            padding: 20px 30px;
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            text-align: center;
            z-index: 100;
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }

            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1);
            }

            80% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
        }

        .vidas {
            position: fixed;
            top: calc(env(safe-area-inset-top) + 8px);
            left: 8px;
            background: rgba(0, 0, 0, .35);
            border: 1px solid rgba(255, 255, 255, .15);
            border-radius: 999px;
            padding: 8px 12px;
            font-weight: 800;
            font-size: 14px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, .25);
            z-index: 11;
        }

        /* Nuevos estilos para efectos visuales */
        .efecto-destello {
            position: absolute;
            border-radius: 8px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, rgba(255, 107, 157, 0.4) 70%, rgba(255, 107, 157, 0) 100%);
            pointer-events: none;
            z-index: 5;
            animation: destello 0.5s ease-out forwards;
        }

        @keyframes destello {
            0% {
                opacity: 0;
                transform: scale(0.8);
            }

            50% {
                opacity: 1;
                transform: scale(1.1);
            }

            100% {
                opacity: 0;
                transform: scale(1.2);
            }
        }

        #modalReiniciar {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(0, 0, 0, .6);
            z-index: 25;
        }

        #modalReiniciar[hidden] {
            display: none;
        }

        .btn.booster.activo {
            outline: 3px solid var(--acento-1);
            box-shadow: 0 0 0 4px rgba(255, 107, 157, .25);
        }

        .btn.booster {
            position: relative;
            width: 64px;
            height: 64px;
            padding: 0;
            margin: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            border: none;
            ;
            border-radius: 16px;
            background-repeat: no-repeat;
            background-position: center;
            background-size: 100% 100%;
        }

        .btn.booster::after {
            content: attr(data-count);
            position: absolute;
            top: -6px;
            right: -6px;
            width: 24px;
            height: 24px;
            border-radius: 999px;
            background: linear-gradient(90deg, var(--acento-1), var(--acento-2));
            color: #fff;
            font-weight: 900;
            font-size: 12px;
            line-height: 24px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, .35);
        }

        .btn[disabled] {
            opacity: .45;
            cursor: not-allowed;
            filter: grayscale(80%);
        }

        .btn.booster[disabled]::after {
            background: #5b5b6a;
            color: #ddd;
        }
    </style>
</head>

<body>
    <div id="contenedor">
        <canvas id="juego" aria-label="Juego Match-3 de corazones"></canvas>
    </div>

    <div class="interfazUsuario">
        <div class="chip" id="IUPuntaje">Nivel: 1 ‚Ä¢ Puntaje: 0 ‚Ä¢ Movimientos: 25</div>
    </div>

    <div class="vidas" id="IUVidas">Vidas: 5</div>

    <div class="barra-superior">
        <button id="btnAudio" class="pildora">üîä Sonido</button>
        <button id="btnReiniciar" class="pildora">Reiniciar</button>
        <button id="btnSalir" class="pildora">üè† Men√∫</button>
    </div>

    <div class="controles">
        <button class="btn booster" id="btnBoosterCupido" title="Cupido"></button>
        <button class="btn booster" id="btnBoosterMano" title="Mano"></button>
        <button class="btn booster" id="btnBoosterBombon" title="Bomb√≥n"></button>
    </div>

    <div id="pantallaInicio">
        <div class="panel-inicio">
            <h1>Love Crush</h1>
            <div class="instrucciones">
                <p><strong>Como jugar:</strong></p>
                <ul>
                    <li>Intercambia corazones adyacentes para hacer match de 3+</li>
                    <li>4 en linea = Corazon Rayado (destruye fila/columna)</li>
                    <li>Forma L/T = Corazon Envuelto (explosion 3x3)</li>
                    <li>5 en linea = Corazon Arcoiris (destruye todos del color)</li>
                    <li>Rompe Corazones de Piedra con matches adyacentes</li>
                    <li>Evita las Nubes de Duda que oscurecen el tablero</li>
                    <li>Lleva los besos abajo o empareja los osos segun el nivel</li>
                    <li>Tienes 5 vidas - usalas sabiamente!</li>
                </ul>
            </div>
            <button id="btnComenzar" class="cta">Comenzar</button>
        </div>
    </div>

    <div id="superposicion" hidden>
        <div class="panel">
            <h1 id="tituloSuperposicion">üíî Game Over</h1>
            <p class="linea">Nivel: <b id="nivelActual">1</b></p>
            <p class="linea">Puntaje: <b id="puntajeActual">0</b></p>
            <p class="linea">Objetivo: <b id="objetivoTexto">Alcanzar puntuacion</b></p>
            <p class="frase" id="fraseFinal">"¬°Int√©ntalo de nuevo ‚ô•!"</p>
            <button id="btnContinuar" class="cta">Continuar</button>
        </div>
    </div>

    <div id="modalReiniciar" hidden>
        <div class="panel">
            <h1>üîÅ Reiniciar nivel</h1>
            <p class="linea">¬øSeguro? Perder√°s <b>1 vida</b>.</p>
            <div style="display:flex; gap:8px; justify-content:center; margin-top:12px">
                <button id="btnReiniciarConfirmar" class="cta">S√≠, reiniciar</button>
                <button id="btnReiniciarCancelar" class="pildora">Cancelar</button>
            </div>
        </div>
    </div>

    <!-- Elementos de audio -->
    <audio id="musicaFondo" loop>
        <source
            src="https://res.cloudinary.com/dsf9hse1e/video/upload/v1756519542/Mini-Game_Land_Mario_Party_2_x9jkar.mp4"
            type="audio/mpeg">
        Tu navegador no soporta el elemento de audio.
    </audio>

    <script>
        // === Constantes del juego ===
        const MUNDO_ANCHO = 500;
        const MUNDO_ALTO = 750;
        const FILAS = 12;
        const COLUMNAS = 8;
        const TAMA√ëO_CELDA = 60;
        const MARGEN_X = (MUNDO_ANCHO - COLUMNAS * TAMA√ëO_CELDA) / 2;
        const MARGEN_Y = 15;
        const TAP_ASSIST = 16;

        // Im√°genes de corazones
        const IMAGENES_CORAZONES = {
            ROSADO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756271397/Coraz%C3%B3n_Rosado_zipc1c.png',
            MORADO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756271405/Coraz%C3%B3n_Morado_mq3bjf.png',
            AMARILLO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756271398/Coraz%C3%B3n_Amarillo_azvkcn.png',
            NARANJA: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756271399/Coraz%C3%B3n_Naranja_q9um5u.png',
            VERDE: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756271403/Coraz%C3%B3n_Verde_b0akys.png',
            CELESTE: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756354210/Coraz%C3%B3n_Celeste_mdkz6d.png'
        };

        const IMAGENES_ESPECIALES = {
            // Rayados Horizontales
            RAYADO_ROSADO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756273143/Rayado_Rosado_xj6w9o.png',
            RAYADO_MORADO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756273139/Rayado_Morado_cn82wc.png',
            RAYADO_AMARILLO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756353501/Rayado_Amarillo_rlwc0z.png',
            RAYADO_NARANJA: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756273141/Rayado_Naranja_kroan0.png',
            RAYADO_VERDE: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756273145/Rayado_Verde_cmuppx.png',
            RAYADO_CELESTE: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756354492/Rayado_Celeste_fuhcmo.png',
            // Rayados Verticales
            RAYADO_V_ROSADO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756519365/Rayado_Horizontal_Rosado_ls2cfe.png',
            RAYADO_V_MORADO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756519362/Rayado_Horizontal_Morado_rfbzqq.png',
            RAYADO_V_AMARILLO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756519373/Rayado_Horizontal_Amarillo_m9e5hl.png',
            RAYADO_V_NARANJA: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756519347/Rayado_Horizontal_Naranja_zuooiw.png',
            RAYADO_V_VERDE: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756519369/Rayado_Horizontal_Verde_btwcdv.png',
            RAYADO_V_CELESTE: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756519358/Rayado_Horizontal_Celeste_aal7sc.png',
            // Envueltos
            ENVUELTO_ROSADO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756268133/Envuelto_Rosado_bjpyot.png',
            ENVUELTO_MORADO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756268130/Envuelto_Morado_zzajds.png',
            ENVUELTO_AMARILLO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756274417/Envuelto_Amarillo_ljnri5.png',
            ENVUELTO_NARANJA: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756268134/Envuelto_Naranja_shgnmj.png',
            ENVUELTO_VERDE: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756268129/Envuelto_Verde_bfvef2.png',
            ENVUELTO_CELESTE: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756355237/Envuelto_Celeste_mdybng.png',
            // Arco√≠ris
            ARCOIRIS: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756272399/Coraz%C3%B3n_Arcoiris_tn2bzn.png'
        };

        const IMAGENES_ELEMENTOS = {
            PIEDRA: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756272270/Piedras_btiubc.png',
            NUBE: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756272179/Nubes_mrj0eq.png',
            BESO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756269140/Beso_fcfonz.png',
            OSO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756268766/Oso_de_Peluche_mubaz3.png'
        };

        const IMAGENES_BOOSTERS = {
            CUPIDO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756524612/Cupido_betvib.png',
            MANO: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756525572/Mano_sxrhl9.png',
            BOMBON: 'https://res.cloudinary.com/dsf9hse1e/image/upload/v1756525189/Bombones_lnqnxd.png',
        };

        const CORAZONES_BASICOS = Object.keys(IMAGENES_CORAZONES);

        // Tipos especiales
        const TIPOS_ESPECIALES = {
            RAYADO: 'striped',
            ENVUELTO: 'wrapped',
            ARCOIRIS: 'rainbow'
        };

        // Obst√°culos y objetivos
        const ELEMENTOS = {
            PIEDRA: 'stone',
            NUBE: 'cloud',
            BESO: 'kiss',
            OSO: 'bear'
        };

        // Configuraci√≥n de niveles
        const NIVELES_CONFIG = [
            { nivel: 1, objetivo: 'puntuacion', valor: 3500, movimientos: 25, obstaculos: [] },
            { nivel: 2, objetivo: 'puntuacion', valor: 6000, movimientos: 25, obstaculos: [] },
            { nivel: 3, objetivo: 'puntuacion', valor: 10000, movimientos: 25, obstaculos: ['piedra'] },
            { nivel: 4, objetivo: 'besos', valor: 3, movimientos: 30, obstaculos: ['piedra'] },
            { nivel: 5, objetivo: 'besos', valor: 5, movimientos: 30, obstaculos: ['nube'] },
            { nivel: 6, objetivo: 'besos', valor: 8, movimientos: 35, obstaculos: ['nube'] },
            { nivel: 7, objetivo: 'osos', valor: 3, movimientos: 35, obstaculos: ['piedra', 'nube'] },
            { nivel: 8, objetivo: 'osos', valor: 4, movimientos: 40, obstaculos: ['piedra', 'nube'] },
            { nivel: 9, objetivo: 'osos', valor: 5, movimientos: 40, obstaculos: ['piedra', 'nube'] },
            { nivel: 10, objetivo: 'osos', valor: 6, movimientos: 45, obstaculos: ['piedra', 'nube'] }
        ];

        const BOOSTERS = {
            CUPIDO: 'cupido',
            MANO: 'mano',
            BOMBON: 'bombon'
        };

        // Referencias DOM
        const lienzo = document.getElementById('juego');
        const contexto = lienzo.getContext('2d');
        const IUPuntaje = document.getElementById('IUPuntaje');
        const IUVidas = document.getElementById('IUVidas');
        const pantallaInicio = document.getElementById('pantallaInicio');
        const superposicion = document.getElementById('superposicion');
        const musicaFondo = document.getElementById('musicaFondo');

        // Estado del juego
        let tablero = [];
        let nivel = 1;
        let puntaje = 0;
        let movimientos = 25;
        let vidas = 5;
        let juegoIniciado = false;
        let seleccionado = null;
        let animando = false;
        let objetivo = 'puntuacion';
        let objetivoValor = 3500;
        let particulas = [];
        let besosEntregados = 0;
        let ososEmparejados = 0;
        let suprimirEfectosUnaVez = false;
        let colaActivaciones = [];
        let pendientesSegundaExplosion = [];
        let UID = 1;
        let ultimaDireccionIntercambio = null;
        let boosterActivo = null;
        let seleccionBooster = null;

        let boosterRestantes = {
            [BOOSTERS.CUPIDO]: 1,
            [BOOSTERS.MANO]: 1,
            [BOOSTERS.BOMBON]: 1,
        };

        function resetBoostersNuevaPartida() {
            boosterRestantes[BOOSTERS.CUPIDO] = 1;
            boosterRestantes[BOOSTERS.MANO] = 1;
            boosterRestantes[BOOSTERS.BOMBON] = 1;
            actualizarUIBoosters();
        }

        function actualizarUIBoosters() {
            const map = [
                ['btnBoosterCupido', BOOSTERS.CUPIDO, 'Cupido'],
                ['btnBoosterMano', BOOSTERS.MANO, 'Mano'],
                ['btnBoosterBombon', BOOSTERS.BOMBON, 'Bomb√≥n'],
            ];
            map.forEach(([btnId, tipo]) => {
                const btn = document.getElementById(btnId);
                if (!btn) return;
                const left = boosterRestantes[tipo] ?? 0;
                btn.disabled = left <= 0;
                btn.classList.toggle('activo', boosterActivo === tipo);

                // SOLO n√∫mero: badge y tooltip
                btn.dataset.count = String(left);   // <- muestra el n√∫mero en el ::after
                btn.textContent = '';               // <- sin texto visible
                btn.title = String(left);           // <- tooltip con solo el n√∫mero
            });
        }

        function consumirBooster(tipo) {
            boosterRestantes[tipo] = Math.max(0, (boosterRestantes[tipo] ?? 0) - 1);
            desactivarBooster();
            actualizarUIBoosters();
        }

        // Variables responsive
        let dpr = 1;
        let escala = 1;
        let desplazamientoX = 0;
        let desplazamientoY = 0;

        // Audio
        let audioCtx = null;
        let masterGain = null;

        // Precargar im√°genes
        let imagenesCargadas = {};
        let imagenesCargando = 0;

        function cargarImagenes() {
            const todasImagenes = { ...IMAGENES_CORAZONES, ...IMAGENES_ESPECIALES, ...IMAGENES_ELEMENTOS };

            Object.keys(todasImagenes).forEach(key => {
                imagenesCargando++;
                const img = new Image();
                img.onload = () => {
                    imagenesCargadas[key] = img;
                    imagenesCargando--;
                };
                img.onerror = () => {
                    console.error('Error cargando imagen:', todasImagenes[key]);
                    imagenesCargando--;
                };
                img.src = todasImagenes[key];
            });
        }

        function aplicarIconosBoosters() {
            const setIcon = (btn, url) => {
                if (!btn || !url) return;
                btn.style.backgroundImage = `url(${url})`;
            };
            setIcon(document.getElementById('btnBoosterCupido'), IMAGENES_BOOSTERS.CUPIDO);
            setIcon(document.getElementById('btnBoosterMano'), IMAGENES_BOOSTERS.MANO);
            setIcon(document.getElementById('btnBoosterBombon'), IMAGENES_BOOSTERS.BOMBON);
        }

        async function setupAudio() {
            if (audioCtx) return;
            try {
                const AC = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AC();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.3;
                masterGain.connect(audioCtx.destination);
            } catch (e) {
                console.log('Audio no disponible');
            }
        }

        function playTone(frequency, duration = 0.1) {
            if (!audioCtx) return;
            try {
                const osc = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                osc.connect(gainNode);
                gainNode.connect(masterGain);

                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + duration);
            } catch (e) { }
        }

        function playBoosterCupid() {
            if (!audioCtx) return;
            const t = audioCtx.currentTime;
            const o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.type = 'triangle';
            o.frequency.setValueAtTime(880, t);
            g.gain.setValueAtTime(0.0001, t);
            g.gain.exponentialRampToValueAtTime(0.35, t + 0.02);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
            o.connect(g); g.connect(masterGain);
            o.start(t); o.stop(t + 0.26);
        }
        function playBoosterHand() {
            // tres bips cortos (swap)
            [392, 523, 392].forEach((f, i) => setTimeout(() => playTone(f, 0.08), i * 90));
        }
        function playBoosterBombon() {
            // barrido descendente (limpieza masiva)
            if (!audioCtx) return;
            const t = audioCtx.currentTime;
            const o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.type = 'sawtooth';
            o.frequency.setValueAtTime(220, t);
            o.frequency.exponentialRampToValueAtTime(55, t + 0.5);
            g.gain.setValueAtTime(0.35, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
            o.connect(g); g.connect(masterGain);
            o.start(t); o.stop(t + 0.52);
        }

        function activarBooster(tipo) {
            if ((boosterRestantes[tipo] ?? 0) <= 0) {
                mostrarMensaje('Sin usos disponibles');
                return;
            }
            // Toggle: si vuelves a tocar el mismo, se desactiva
            if (boosterActivo === tipo) {
                desactivarBooster();
                return;
            }

            boosterActivo = tipo;
            seleccionBooster = null;
            document.querySelectorAll('.btn.booster').forEach(b => b.classList.remove('activo'));
            if (tipo === BOOSTERS.CUPIDO) document.getElementById('btnBoosterCupido')?.classList.add('activo');
            if (tipo === BOOSTERS.MANO) document.getElementById('btnBoosterMano')?.classList.add('activo');
            if (tipo === BOOSTERS.BOMBON) document.getElementById('btnBoosterBombon')?.classList.add('activo');
            actualizarUIBoosters();
        }

        function desactivarBooster() {
            boosterActivo = null;
            seleccionBooster = null;
            document.querySelectorAll('.btn.booster').forEach(b => b.classList.remove('activo'));
            actualizarUIBoosters();
        }

        // Utilidades
        function marcarParaEliminar(fila, col, score = 100) {
            const celda = tablero[fila]?.[col];
            if (!celda || celda.tipo !== 'normal') return;

            if (celda.especial && !celda._pendienteActivar) {
                celda._pendienteActivar = true;

                if (esRayadoH(celda)) {
                    colaActivaciones.push({ tipo: 'rayado_h', fila, col });
                } else if (esRayadoV(celda)) {
                    colaActivaciones.push({ tipo: 'rayado_v', fila, col });
                } else if (esEnvuelto(celda)) {
                    if (!celda._uid) celda._uid = UID++;
                    colaActivaciones.push({ tipo: 'envuelto_primera', fila, col, uid: celda._uid });
                } else if (esArcoiris(celda)) {
                    // Arco√≠ris "tocado" por otro efecto: elige un color presente y l√≠mpialo
                    const colores = new Set();
                    for (let f = 0; f < FILAS; f++) for (let c = 0; c < COLUMNAS; c++) {
                        const cc = tablero[f][c];
                        if (cc && cc.tipo === 'normal' && !cc.especial) colores.add(cc.color);
                    }
                    const arr = Array.from(colores);
                    if (arr.length) colaActivaciones.push({ tipo: 'arcoiris_color', color: elegirAleatorio(arr) });
                }
                return;
            }

            celda._eliminar = true;
            celda._score = Math.max(celda._score || 0, score);
        }

        function resolverActivacionesYEliminaciones() {
            // Ejecutar todas las activaciones pendientes (pueden encolar m√°s)
            while (colaActivaciones.length > 0) {
                const act = colaActivaciones.shift();

                if (act.tipo === 'rayado_h') {
                    crearEfectoDestelloFila(act.fila);
                    for (let c = 0; c < COLUMNAS; c++) marcarParaEliminar(act.fila, c); // 100 por defecto
                    const celda = tablero[act.fila]?.[act.col];
                    if (celda) { celda._eliminar = true; celda._score = Math.max(celda._score || 0, 100); }
                }
                else if (act.tipo === 'rayado_v') {
                    crearEfectoDestelloColumna(act.col);
                    for (let f = 0; f < FILAS; f++) marcarParaEliminar(f, act.col); // 100 por defecto
                    const celda = tablero[act.fila]?.[act.col];
                    if (celda) { celda._eliminar = true; celda._score = Math.max(celda._score || 0, 100); }
                }
                else if (act.tipo === 'envuelto_primera') {
                    explosion3x3({ fila: act.fila, col: act.col }, true); // preservar centro
                    pendientesSegundaExplosion.push({ uid: act.uid });
                }
                else if (act.tipo === 'envuelto_segunda') {
                    let pos = null;
                    for (let f = 0; f < FILAS; f++) for (let c = 0; c < COLUMNAS; c++) {
                        const cc = tablero[f][c];
                        if (cc && cc.tipo === 'normal' && cc.especial && cc._uid === act.uid) pos = { fila: f, col: c };
                    }
                    if (pos) {
                        explosion3x3(pos, false); // ahora s√≠ incluye centro
                        const celda = tablero[pos.fila]?.[pos.col];
                        if (celda) { celda._eliminar = true; celda._score = Math.max(celda._score || 0, 100); }
                    }
                }
                else if (act.tipo === 'arcoiris_color') {
                    // eliminarTodosDelColor ya marcar√° con 200 si le pasaste el score en marcarParaEliminar
                    eliminarTodosDelColor(act.color);
                }
            }

            // Borrado efectivo y puntos (sumando el _score de cada celda)
            let total = 0;
            for (let f = 0; f < FILAS; f++) for (let c = 0; c < COLUMNAS; c++) {
                const celda = tablero[f][c];
                if (celda && celda._eliminar) {
                    crearParticulas(f, c);
                    total += (celda._score ?? 100); // fallback a 100 si no hay _score
                    tablero[f][c] = null;
                }
            }
            if (total > 0) puntaje += total;

            // Gravedad + rellenar
            aplicarGravedad();
            llenarEspaciosVacios();

            // Segunda explosi√≥n de envueltos (ya con ca√≠das)
            if (pendientesSegundaExplosion.length > 0) {
                const pendientes = pendientesSegundaExplosion.slice();
                pendientesSegundaExplosion = [];
                pendientes.forEach(p => colaActivaciones.push({ tipo: 'envuelto_segunda', uid: p.uid }));
                resolverActivacionesYEliminaciones(); // ejecuta segunda ronda
            }

            // Limpieza flags
            for (let f = 0; f < FILAS; f++) for (let c = 0; c < COLUMNAS; c++) {
                const celda = tablero[f][c];
                if (celda) {
                    delete celda._pendienteActivar;
                    delete celda._eliminar;
                    delete celda._score; // <-- importante
                }
            }
        }

        function aleatorio(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function elegirAleatorio(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function mostrarMensaje(texto) {
            const mensaje = document.createElement('div');
            mensaje.className = 'mensaje-temporal';
            mensaje.textContent = texto;
            document.body.appendChild(mensaje);

            setTimeout(() => {
                if (mensaje.parentNode) {
                    mensaje.parentNode.removeChild(mensaje);
                }
            }, 2000);
        }

        // Helpers de rayados con orientaci√≥n
        function esRayado(celda) {
            return !!(celda && celda.especial && (
                celda.especial.startsWith('RAYADO_H_') ||
                celda.especial.startsWith('RAYADO_V_') ||
                celda.especial.startsWith('RAYADO_')       // compat: antiguos = horizontales
            ));
        }
        function esRayadoH(celda) {
            return !!(celda && celda.especial && (
                celda.especial.startsWith('RAYADO_H_') ||
                (celda.especial.startsWith('RAYADO_') && !celda.especial.startsWith('RAYADO_V_')) // compat
            ));
        }
        function esRayadoV(celda) {
            return !!(celda && celda.especial && celda.especial.startsWith('RAYADO_V_'));
        }
        function esEnvuelto(celda) {
            return !!(celda && celda.especial && celda.especial.startsWith('ENVUELTO_'));
        }
        function esArcoiris(celda) {
            return !!(celda && celda.especial === TIPOS_ESPECIALES.ARCOIRIS);
        }

        function obtenerColorDeEspecial(especial) {
            if (especial.startsWith('RAYADO_H_')) return especial.replace('RAYADO_H_', '');
            if (especial.startsWith('RAYADO_V_')) return especial.replace('RAYADO_V_', '');
            if (especial.startsWith('RAYADO_')) return especial.replace('RAYADO_', ''); // compat
            if (especial.startsWith('ENVUELTO_')) return especial.replace('ENVUELTO_', '');
            return null;
        }

        function abrirModalReiniciar() { document.getElementById('modalReiniciar').hidden = false; }
        function cerrarModalReiniciar() { document.getElementById('modalReiniciar').hidden = true; }

        function toggleMusica() {
            try {
                if (musicaFondo.paused) {
                    musicaFondo.volume = 0.25;
                    musicaFondo.play();
                    document.getElementById('btnAudio').textContent = 'üîä M√∫sica';
                } else {
                    musicaFondo.pause();
                    document.getElementById('btnAudio').textContent = 'üîá M√∫sica';
                }
            } catch (e) { }
        }

        // Responsive
        function redimensionar() {
            const cssAncho = window.innerWidth;
            const cssAlto = window.innerHeight;
            dpr = Math.min(window.devicePixelRatio || 1, 2);

            lienzo.width = Math.floor(cssAncho * dpr);
            lienzo.height = Math.floor(cssAlto * dpr);

            const escalaX = cssAncho / MUNDO_ANCHO;
            const escalaY = cssAlto / MUNDO_ALTO;
            escala = Math.min(escalaX, escalaY) * 0.9;

            desplazamientoX = (cssAncho - MUNDO_ANCHO * escala) / 2;
            desplazamientoY = (cssAlto - MUNDO_ALTO * escala) / 2;
        }

        function establecerTransformacionMundo() {
            contexto.setTransform(dpr, 0, 0, dpr, 0, 0);
            contexto.translate(desplazamientoX, desplazamientoY);
            contexto.scale(escala, escala);
        }

        // Inicializaci√≥n del tablero
        function crearTablero() {
            const config = NIVELES_CONFIG[nivel - 1];
            tablero = [];
            besosEntregados = 0;
            ososEmparejados = 0;

            for (let fila = 0; fila < FILAS; fila++) {
                tablero[fila] = [];
                for (let col = 0; col < COLUMNAS; col++) {
                    // Agregar obst√°culos seg√∫n configuraci√≥n del nivel
                    if (config.obstaculos.includes('piedra') && Math.random() < 0.1) {
                        tablero[fila][col] = { tipo: 'obstaculo', elemento: ELEMENTOS.PIEDRA };
                    } else if (config.obstaculos.includes('nube') && Math.random() < 0.08) {
                        tablero[fila][col] = { tipo: 'obstaculo', elemento: ELEMENTOS.NUBE };
                    } else if (config.objetivo === 'besos' && fila === 0 && Math.random() < 0.3) {
                        tablero[fila][col] = { tipo: 'objetivo', elemento: ELEMENTOS.BESO };
                    } else if (config.objetivo === 'osos' && Math.random() < 0.15) {
                        tablero[fila][col] = { tipo: 'objetivo', elemento: ELEMENTOS.OSO, pareja: aleatorio(1, 3) };
                    } else {
                        let corazon;
                        do {
                            corazon = elegirAleatorio(CORAZONES_BASICOS);
                        } while (verificarMatchInicial(fila, col, corazon));

                        tablero[fila][col] = { tipo: 'normal', color: corazon };
                    }
                }
            }

            // Configurar objetivos y movimientos para el nivel
            objetivo = config.objetivo;
            objetivoValor = config.valor;
            movimientos = config.movimientos;
        }

        function verificarMatchInicial(fila, col, corazon) {
            // Verificar horizontal
            if (col >= 2) {
                const celda1 = tablero[fila][col - 1];
                const celda2 = tablero[fila][col - 2];
                if (celda1 && celda1.tipo === 'normal' && celda1.color === corazon &&
                    celda2 && celda2.tipo === 'normal' && celda2.color === corazon) {
                    return true;
                }
            }

            // Verificar vertical
            if (fila >= 2) {
                const celda1 = tablero[fila - 1][col];
                const celda2 = tablero[fila - 2][col];
                if (celda1 && celda1.tipo === 'normal' && celda1.color === corazon &&
                    celda2 && celda2.tipo === 'normal' && celda2.color === corazon) {
                    return true;
                }
            }

            return false;
        }

        // Posicionamiento y eventos
        function obtenerPosicionTablero(x, y) {
            // coords relativas al tablero
            const cx = x - MARGEN_X;
            const cy = y - MARGEN_Y;

            const ancho = COLUMNAS * TAMA√ëO_CELDA;
            const alto = FILAS * TAMA√ëO_CELDA;

            // si el toque est√° muy lejos, ignorar (pero dejamos un margen TAP_ASSIST)
            if (cx < -TAP_ASSIST || cy < -TAP_ASSIST || cx > ancho + TAP_ASSIST || cy > alto + TAP_ASSIST) {
                return null;
            }

            // elegir la celda por centro m√°s cercano en vez de por ‚Äúfloor‚Äù
            let col = Math.round((cx - TAMA√ëO_CELDA / 2) / TAMA√ëO_CELDA);
            let fila = Math.round((cy - TAMA√ëO_CELDA / 2) / TAMA√ëO_CELDA);

            // clamp para no salirnos
            col = Math.max(0, Math.min(COLUMNAS - 1, col));
            fila = Math.max(0, Math.min(FILAS - 1, fila));

            return { fila, col };
        }

        function configurarEventos() {
            lienzo.addEventListener('pointerdown', manejarClick, { passive: false });
            document.getElementById('btnComenzar').addEventListener('click', iniciarJuego);
            document.getElementById('btnContinuar').addEventListener('click', continuarJuego);

            // Reiniciar con confirmaci√≥n (quita si ten√≠as antes el addEventListener directo a reiniciarNivel)
            document.getElementById('btnReiniciar').addEventListener('click', abrirModalReiniciar);
            document.getElementById('btnReiniciarConfirmar').addEventListener('click', () => {
                cerrarModalReiniciar();
                vidas = Math.max(0, vidas - 1);
                if (vidas <= 0) {
                    mostrarSuperposicion('Nivel Fallido', 'Int√©ntalo de nuevo ‚ô•');
                    actualizarUI();
                    return;
                }
                crearTablero();
                puntaje = 0;
                actualizarUI();
            });
            document.getElementById('btnReiniciarCancelar').addEventListener('click', cerrarModalReiniciar);

            // M√∫sica
            document.getElementById('btnAudio').addEventListener('click', toggleMusica);

            // Boosters
            document.getElementById('btnBoosterCupido').addEventListener('click', () => activarBooster(BOOSTERS.CUPIDO));
            document.getElementById('btnBoosterMano').addEventListener('click', () => activarBooster(BOOSTERS.MANO));
            document.getElementById('btnBoosterBombon').addEventListener('click', () => activarBooster(BOOSTERS.BOMBON));
            actualizarUIBoosters();
        }

        function manejarClick(e) {
            if (!juegoIniciado || animando) return;

            e.preventDefault();

            if (e.pointerId != null && lienzo.setPointerCapture) {
                try { lienzo.setPointerCapture(e.pointerId); } catch (_) { }
            }

            const rect = lienzo.getBoundingClientRect();
            const x = (e.clientX - rect.left - desplazamientoX) / escala;
            const y = (e.clientY - rect.top - desplazamientoY) / escala;

            const pos = obtenerPosicionTablero(x, y);
            if (!pos) return;

            const celda = tablero[pos.fila][pos.col];
            if (!celda || celda.tipo === 'obstaculo') return;

            // === BOOSTERS ===
            if (boosterActivo) {
                // 1) CUPIDO: elimina la celda elegida (activa efecto si es especial)
                if (boosterActivo === BOOSTERS.CUPIDO) {
                    if (celda && celda.tipo === 'normal') {
                        marcarParaEliminar(pos.fila, pos.col, 150);
                        playBoosterCupid();
                        resolverActivacionesYEliminaciones();
                        actualizarUI();
                        consumirBooster(BOOSTERS.CUPIDO);
                        setTimeout(() => { procesarMatches(); }, 200);
                    } else {
                        mostrarMensaje('Selecciona un coraz√≥n v√°lido');
                    }
                    return;
                }

                // 2) MANO: intercambia dos adyacentes sin exigir match
                if (boosterActivo === BOOSTERS.MANO) {
                    if (!seleccionBooster) {
                        if (celda && celda.tipo === 'normal') {
                            seleccionBooster = pos;
                            playTone(500, 0.1);
                        } else {
                            mostrarMensaje('Selecciona un coraz√≥n');
                        }
                    } else {
                        // Si tocas de nuevo el mismo, deselecciona
                        if (pos.fila === seleccionBooster.fila && pos.col === seleccionBooster.col) {
                            seleccionBooster = null;
                            playTone(300, 0.08); // peque√±o ‚Äúclick‚Äù de cancelaci√≥n
                            return;
                        }

                        if (!sonAdyacentes(seleccionBooster, pos)) {
                            mostrarMensaje('Deben ser adyacentes');
                            return;
                        }
                        const a = seleccionBooster, b = pos;
                        const tmp = tablero[a.fila][a.col];
                        tablero[a.fila][a.col] = tablero[b.fila][b.col];
                        tablero[b.fila][b.col] = tmp;
                        playBoosterHand();
                        consumirBooster(BOOSTERS.MANO);
                        desactivarBooster();
                        // no resta movimientos; si quieres que cuente, resta aqu√≠
                        procesarMatches();
                    }
                    return;
                }

                // 3) BOMB√ìN: elige un color tocando un coraz√≥n de ese color, limpia todo
                if (boosterActivo === BOOSTERS.BOMBON) {
                    let color = null;
                    if (celda.tipo === 'normal') {
                        if (celda.especial && celda.especial !== TIPOS_ESPECIALES.ARCOIRIS) {
                            color = obtenerColorDeEspecial(celda.especial);
                        } else if (!celda.especial) {
                            color = celda.color;
                        }
                    }
                    if (!color) {
                        mostrarMensaje('Toca un coraz√≥n de color');
                        return;
                    }
                    eliminarTodosDelColor(color);
                    playBoosterBombon();
                    resolverActivacionesYEliminaciones();
                    actualizarUI();
                    consumirBooster(BOOSTERS.BOMBON);
                    return;
                }
            }

            // === JUEGO NORMAL ===
            if (!seleccionado) {
                seleccionado = pos;
                playTone(440, 0.1);
            } else {
                if (pos.fila === seleccionado.fila && pos.col === seleccionado.col) {
                    seleccionado = null;
                } else if (sonAdyacentes(seleccionado, pos)) {
                    intentarIntercambio(seleccionado, pos);
                    seleccionado = null;
                } else {
                    seleccionado = pos;
                    playTone(440, 0.1);
                }
            }
        }

        function sonAdyacentes(pos1, pos2) {
            const deltaFila = Math.abs(pos1.fila - pos2.fila);
            const deltaCol = Math.abs(pos1.col - pos2.col);
            return (deltaFila === 1 && deltaCol === 0) || (deltaFila === 0 && deltaCol === 1);
        }

        function intentarIntercambio(pos1, pos2) {
            const celda1 = tablero[pos1.fila][pos1.col];
            const celda2 = tablero[pos2.fila][pos2.col];

            if (celda1.tipo === 'obstaculo' || celda2.tipo === 'obstaculo') return;

            // === CASO ESPECIAL: RAYADO + RAYADO (cruz simple) ===
            if (esRayado(celda1) && esRayado(celda2)) {
                const centroFila = Math.floor((pos1.fila + pos2.fila) / 2);
                const centroCol = Math.floor((pos1.col + pos2.col) / 2);
                destruirCruzSimple({ fila: centroFila, col: centroCol }); // tu helper de cruz simple
                movimientos--;
                actualizarUI();
                resolverActivacionesYEliminaciones();
                setTimeout(() => {
                    aplicarGravedad();
                    llenarEspaciosVacios();
                    procesarMatches();
                }, 300);
                return;
            }

            // CASO ESPECIAL: CORAZ√ìN ARCO√çRIS + ARCO√çRIS
            if (celda1.especial === TIPOS_ESPECIALES.ARCOIRIS && celda2.especial === TIPOS_ESPECIALES.ARCOIRIS) {
                // Eliminar todos los corazones del tablero
                limpiarTableroCompleto();
                movimientos--;
                actualizarUI();
                //mostrarMensaje('¬°Doble arco√≠ris! ¬°Tablero limpio!');
                playTone(880, 0.5);
                resolverActivacionesYEliminaciones();

                // Aplicar gravedad y llenar espacios
                setTimeout(() => {
                    aplicarGravedad();
                    llenarEspaciosVacios();
                    procesarMatches();
                }, 300);
                return;
            }

            // CASO ESPECIAL: CORAZ√ìN ARCO√çRIS + OTRO
            if (celda1.especial === TIPOS_ESPECIALES.ARCOIRIS || celda2.especial === TIPOS_ESPECIALES.ARCOIRIS) {
                const arcoiris = (celda1.especial === TIPOS_ESPECIALES.ARCOIRIS) ? celda1 : celda2;
                const otro = (arcoiris === celda1) ? celda2 : celda1;

                // Si el otro es RAYADO_x -> convertir todos los normales de ese color a rayados y detonar
                if (otro.especial && otro.especial.startsWith('RAYADO_')) {
                    const color = obtenerColorDeEspecial(otro.especial);
                    convertirYExplotarRayados(color);
                }
                // Si el otro es ENVUELTO_x -> convertir todos los normales de ese color a envueltos y detonar
                else if (otro.especial && otro.especial.startsWith('ENVUELTO_')) {
                    const color = obtenerColorDeEspecial(otro.especial);
                    convertirYExplotarEnvueltos(color);
                }
                // Si el otro es normal -> eliminar todos de ese color
                else {
                    const colorObjetivo = otro.color || obtenerColorDeEspecial(otro.especial);
                    if (colorObjetivo) eliminarTodosDelColor(colorObjetivo);
                }

                movimientos--;
                actualizarUI();
                resolverActivacionesYEliminaciones();
                setTimeout(() => { aplicarGravedad(); llenarEspaciosVacios(); procesarMatches(); }, 300);
                playTone(659, 0.3);
                return;
            }

            // CASO ESPECIAL: ENVUELTO + ENVUELTO
            if ((celda1.especial && celda1.especial.startsWith('ENVUELTO_')) &&
                (celda2.especial && celda2.especial.startsWith('ENVUELTO_'))) {
                explosion5x5(pos1, pos2);
                movimientos--;
                actualizarUI();
                //mostrarMensaje('¬°Doble envuelto! ¬°Gran explosi√≥n!');
                playTone(880, 0.4);
                resolverActivacionesYEliminaciones();

                setTimeout(() => {
                    aplicarGravedad();
                    llenarEspaciosVacios();
                    procesarMatches();
                }, 300);
                return;
            }

            // CASO ESPECIAL: RAYADO + ENVUELTO
            if ((esRayado(celda1) && esEnvuelto(celda2)) || (esRayado(celda2) && esEnvuelto(celda1))) {
                suprimirEfectosUnaVez = true;
                destruirCruzExtendida(pos1, pos2);
                movimientos--;
                actualizarUI();
                resolverActivacionesYEliminaciones();
                setTimeout(() => {
                    aplicarGravedad();
                    llenarEspaciosVacios();
                    procesarMatches();
                }, 300);
                return;
            }

            // Guardar estado original para posible reversi√≥n
            const celda1Original = { ...celda1 };
            const celda2Original = { ...celda2 };

            // Intercambiar temporalmente para verificar matches
            tablero[pos1.fila][pos1.col] = celda2;
            tablero[pos2.fila][pos2.col] = celda1;

            // Verificar si hay matches despu√©s del intercambio
            let hayMatch = false;
            const matches1 = encontrarMatches(pos1.fila, pos1.col);
            const matches2 = encontrarMatches(pos2.fila, pos2.col);

            if (matches1.length >= 3 || matches2.length >= 3) {
                hayMatch = true;
            }

            // Si el intercambio fue horizontal o vertical (para orientar rayados creados con 4)
            const fueHorizontal = (pos1.fila === pos2.fila) && (pos1.col !== pos2.col);
            const fueVertical = (pos1.col === pos2.col) && (pos1.fila !== pos2.fila);
            ultimaDireccionIntercambio = fueVertical ? 'vertical' : 'horizontal';

            if (hayMatch) {
                movimientos--;
                actualizarUI();
                procesarMatches();
                playTone(523, 0.15);
            } else {
                // Revertir intercambio
                tablero[pos1.fila][pos1.col] = celda1Original;
                tablero[pos2.fila][pos2.col] = celda2Original;
                playTone(208, 0.3);
            }
        }

        // Funci√≥n para validar intercambios entre corazones especiales y normales
        function validarIntercambioEspecialNormal(pos1, pos2) {
            const celda1 = tablero[pos1.fila][pos1.col];
            const celda2 = tablero[pos2.fila][pos2.col];

            // Determinar cu√°l es el especial y cu√°l es el normal
            let especialPos, normalPos, especial, colorEspecial, colorNormal;

            if (celda1.especial && (celda1.especial.startsWith('RAYADO_') || celda1.especial.startsWith('ENVUELTO_'))) {
                especialPos = pos1;
                normalPos = pos2;
                especial = celda1.especial;
                colorEspecial = obtenerColorDeEspecial(especial);
                colorNormal = celda2.color;
            } else {
                especialPos = pos2;
                normalPos = pos1;
                especial = celda2.especial;
                colorEspecial = obtenerColorDeEspecial(especial);
                colorNormal = celda1.color;
            }

            // Los colores deben coincidir para que sea v√°lido
            if (colorEspecial !== colorNormal) {
                return false;
            }

            // Simular el intercambio temporalmente
            tablero[especialPos.fila][especialPos.col] = { tipo: 'normal', color: colorNormal };
            tablero[normalPos.fila][normalPos.col] = { tipo: 'normal', color: colorNormal, especial: especial };

            // Verificar si hay matches despu√©s del intercambio
            const matchesEspecial = encontrarMatches(normalPos.fila, normalPos.col);
            const matchesNormal = encontrarMatches(especialPos.fila, especialPos.col);
            const todosLosMatches = encontrarTodosLosMatches();

            // Revertir la simulaci√≥n
            tablero[especialPos.fila][especialPos.col] = celda1;
            tablero[normalPos.fila][normalPos.col] = celda2;

            // Permitir el intercambio si hay al menos 3 matches en cualquier parte del tablero
            return matchesEspecial.length >= 3 || matchesNormal.length >= 3 || todosLosMatches.length >= 3;
        }

        function activarEfectoEspecial(pos1, pos2) {
            const celda1 = tablero[pos1.fila][pos1.col];
            const celda2 = tablero[pos2.fila][pos2.col];

            let especialPos, normalPos, especial, colorNormal;

            if (celda1.especial) {
                especialPos = pos1; normalPos = pos2; especial = celda1.especial; colorNormal = celda2.color;
            } else {
                especialPos = pos2; normalPos = pos1; especial = celda2.especial; colorNormal = celda1.color;
            }

            if (especial.startsWith('RAYADO_V_')) {
                destruirFilaOColumna(especialPos, 'vertical');
            } else if (especial.startsWith('RAYADO_')) {
                destruirFilaOColumna(especialPos, 'horizontal');
            } else if (especial.startsWith('ENVUELTO_')) {
                explosion3x3(especialPos);
            } else if (especial === TIPOS_ESPECIALES.ARCOIRIS) {
                if (colorNormal) eliminarTodosDelColor(colorNormal);
            }

            // No borres aqu√≠; el resolvedor lo har√° si procede
            return true;
        }

        function determinarDireccionRayado(especialPos, normalPos) {
            // Si est√°n en la misma fila, es horizontal (destruir fila)
            if (especialPos.fila === normalPos.fila) return 'horizontal';
            // Si est√°n en la misma columna, es vertical (destruir columna)
            if (especialPos.col === normalPos.col) return 'vertical';
            // Por defecto, usar horizontal
            return 'horizontal';
        }

        function destruirFilaOColumna(pos, direccion) {
            if (direccion === 'horizontal') {
                crearEfectoDestelloFila(pos.fila);
                for (let c = 0; c < COLUMNAS; c++) marcarParaEliminar(pos.fila, c);
            } else {
                crearEfectoDestelloColumna(pos.col);
                for (let f = 0; f < FILAS; f++) marcarParaEliminar(f, pos.col);
            }
        }

        function explosion3x3(pos, preservarCentro = false) {
            for (let df = -1; df <= 1; df++) for (let dc = -1; dc <= 1; dc++) {
                const f = pos.fila + df, c = pos.col + dc;
                if (f >= 0 && f < FILAS && c >= 0 && c < COLUMNAS) {
                    if (preservarCentro && df === 0 && dc === 0) continue;
                    marcarParaEliminar(f, c);
                }
            }
            crearEfectoDestelloArea(pos.fila, pos.col, 3);
        }

        function eliminarTodosDelColor(color) {
            for (let f = 0; f < FILAS; f++) for (let c = 0; c < COLUMNAS; c++) {
                const celda = tablero[f][c];
                if (celda && celda.tipo === 'normal') {
                    let colorCelda = celda.especial && celda.especial !== TIPOS_ESPECIALES.ARCOIRIS
                        ? obtenerColorDeEspecial(celda.especial)
                        : celda.color;
                    if (colorCelda === color) marcarParaEliminar(f, c, 200);
                }
            }
            crearEfectoDestelloMultiple();
        }

        function hayCombinaci√≥nEspecial(pos1, pos2) {
            const celda1 = tablero[pos1.fila][pos1.col];
            const celda2 = tablero[pos2.fila][pos2.col];

            return (celda1.especial || celda2.especial);
        }

        function procesarCombinaci√≥nEspecial(pos1, pos2) {
            const celda1 = tablero[pos1.fila][pos1.col];
            const celda2 = tablero[pos2.fila][pos2.col];

            // Rayado + Rayado = Cruz completa
            if ((celda1.especial && celda1.especial.startsWith('RAYADO_')) &&
                (celda2.especial && celda2.especial.startsWith('RAYADO_'))) {
                destruirFilaOColumna(pos1, 'horizontal');
                destruirFilaOColumna(pos1, 'vertical');
                //mostrarMensaje('¬°Cruz completa!');
            }
            // Rayado + Envuelto = Cruz con filas/columns adyacentes
            else if (((celda1.especial && celda1.especial.startsWith('RAYADO_')) &&
                (celda2.especial && celda2.especial.startsWith('ENVUELTO_'))) ||
                ((celda1.especial && celda1.especial.startsWith('ENVUELTO_')) &&
                    (celda2.especial && celda2.especial.startsWith('RAYADO_')))) {
                destruirCruzExtendida(pos1);
                //mostrarMensaje('¬°Cruz extendida!');
            }
            // Envuelto + Envuelto = Explosi√≥n 5x5
            else if ((celda1.especial && celda1.especial.startsWith('ENVUELTO_')) &&
                (celda2.especial && celda2.especial.startsWith('ENVUELTO_'))) {
                explosion5x5(pos1, pos2);
                //mostrarMensaje('¬°Gran explosi√≥n!');
            }
            // Arco√≠ris + Rayado = Convertir todos del color en rayados y explotar
            else if (celda1.especial === TIPOS_ESPECIALES.ARCOIRIS &&
                celda2.especial && celda2.especial.startsWith('RAYADO_')) {
                const color = celda2.especial.replace('RAYADO_', '');
                convertirYExplotarRayados(color);
            }
            else if (celda2.especial === TIPOS_ESPECIALES.ARCOIRIS &&
                celda1.especial && celda1.especial.startsWith('RAYADO_')) {
                const color = celda1.especial.replace('RAYADO_', '');
                convertirYExplotarRayados(color);
            }
            // Arco√≠ris + Envuelto = Convertir todos del color en envueltos y explotar
            else if (celda1.especial === TIPOS_ESPECIALES.ARCOIRIS &&
                celda2.especial && celda2.especial.startsWith('ENVUELTO_')) {
                const color = celda2.especial.replace('ENVUELTO_', '');
                convertirYExplotarEnvueltos(color);
            }
            else if (celda2.especial === TIPOS_ESPECIALES.ARCOIRIS &&
                celda1.especial && celda1.especial.startsWith('ENVUELTO_')) {
                const color = celda1.especial.replace('ENVUELTO_', '');
                convertirYExplotarEnvueltos(color);
            }
            // Arco√≠ris + Arco√≠ris = Limpiar tablero completo
            else if (celda1.especial === TIPOS_ESPECIALES.ARCOIRIS &&
                celda2.especial === TIPOS_ESPECIALES.ARCOIRIS) {
                limpiarTableroCompleto();
                //mostrarMensaje('¬°Explosi√≥n total!');
            }
            // Arco√≠ris + Normal = Eliminar todos del color
            else if (celda1.especial === TIPOS_ESPECIALES.ARCOIRIS) {
                eliminarTodosDelColor(celda2.color);
                //mostrarMensaje('¬°Poder arco√≠ris!');
            }
            else if (celda2.especial === TIPOS_ESPECIALES.ARCOIRIS) {
                eliminarTodosDelColor(celda1.color);
                //mostrarMensaje('¬°Poder arco√≠ris!');
            }
        }

        function destruirCruzExtendida(pos1, pos2) {
            const cf = Math.floor((pos1.fila + pos2.fila) / 2);
            const cc = Math.floor((pos1.col + pos2.col) / 2);
            for (let df = -1; df <= 1; df++) for (let c = 0; c < COLUMNAS; c++) if (cf + df >= 0 && cf + df < FILAS) marcarParaEliminar(cf + df, c);
            for (let dc = -1; dc <= 1; dc++) for (let f = 0; f < FILAS; f++) if (cc + dc >= 0 && cc + dc < COLUMNAS) marcarParaEliminar(f, cc + dc);
            crearEfectoDestelloArea(cf, cc, 5);
        }

        function destruirCruzSimple(centro) {
            for (let c = 0; c < COLUMNAS; c++) marcarParaEliminar(centro.fila, c);
            for (let f = 0; f < FILAS; f++) marcarParaEliminar(f, centro.col);
            crearEfectoDestelloArea(centro.fila, centro.col, 3);
        }

        /*
        function destruirCruzCompleta(pos) {
            // Destruir 3 filas (arriba, centro, abajo)
            for (let df = -1; df <= 1; df++) {
                const fila = pos.fila + df;
                if (fila >= 0 && fila < FILAS) {
                    for (let col = 0; col < COLUMNAS; col++) {
                        if (tablero[fila][col]) {
                            crearParticulas(fila, col);
                            tablero[fila][col] = null;
                            puntaje += 100;
                        }
                    }
                }
            }

            // Destruir 3 columnas (izquierda, centro, derecha)
            for (let dc = -1; dc <= 1; dc++) {
                const col = pos.col + dc;
                if (col >= 0 && col < COLUMNAS) {
                    for (let fila = 0; fila < FILAS; fila++) {
                        // Evitar duplicar destrucci√≥n en intersecciones ya procesadas
                        if (fila < pos.fila - 1 || fila > pos.fila + 1) {
                            if (tablero[fila][col]) {
                                crearParticulas(fila, col);
                                tablero[fila][col] = null;
                                puntaje += 100;
                            }
                        }
                    }
                }
            }

            // Crear efecto visual para la cruz completa
            crearEfectoDestelloArea(pos.fila, pos.col, 5);
        }*/

        function convertirYExplotarRayados(color) {
            // Primero convertir todos los normales del color en rayados
            const posicionesConvertidas = [];
            for (let fila = 0; fila < FILAS; fila++) {
                for (let col = 0; col < COLUMNAS; col++) {
                    const celda = tablero[fila][col];
                    if (celda && celda.tipo === 'normal' && celda.color === color && !celda.especial) {
                        tablero[fila][col] = {
                            tipo: 'normal',
                            color: color,
                            especial: `RAYADO_${color}`
                        };
                        posicionesConvertidas.push({ fila, col });
                    }
                }
            }

            // Luego explotar todos los rayados de ese color
            setTimeout(() => {
                posicionesConvertidas.forEach(pos => {
                    destruirFilaOColumna(pos, 'horizontal');
                });
                aplicarGravedad();
                llenarEspaciosVacios();
            }, 200);
        }

        function convertirYExplotarEnvueltos(color) {
            // Primero convertir todos los normales del color en envueltos
            const posicionesConvertidas = [];
            for (let fila = 0; fila < FILAS; fila++) {
                for (let col = 0; col < COLUMNAS; col++) {
                    const celda = tablero[fila][col];
                    if (celda && celda.tipo === 'normal' && celda.color === color && !celda.especial) {
                        tablero[fila][col] = {
                            tipo: 'normal',
                            color: color,
                            especial: `ENVUELTO_${color}`
                        };
                        posicionesConvertidas.push({ fila, col });
                    }
                }
            }

            // Luego explotar todos los envueltos de ese color
            setTimeout(() => {
                posicionesConvertidas.forEach(pos => {
                    explosion3x3(pos);
                });
                aplicarGravedad();
                llenarEspaciosVacios();
            }, 200);
        }

        function destruirCruzado(pos1, pos2) {
            // Destruir fila y columna de ambas posiciones
            destruirFilaOColumna(pos1, 'horizontal');
            destruirFilaOColumna(pos1, 'vertical');
            destruirFilaOColumna(pos2, 'horizontal');
            destruirFilaOColumna(pos2, 'vertical');
        }

        function explosion5x5(pos1, pos2) {
            const centroFila = Math.floor((pos1.fila + pos2.fila) / 2);
            const centroCol = Math.floor((pos1.col + pos2.col) / 2);
            for (let df = -2; df <= 2; df++) for (let dc = -2; dc <= 2; dc++) {
                const f = centroFila + df, c = centroCol + dc;
                if (f >= 0 && f < FILAS && c >= 0 && c < COLUMNAS) marcarParaEliminar(f, c);
            }
            crearEfectoDestelloArea(centroFila, centroCol, 5);
        }

        // Sistema de matches
        function encontrarMatches(fila, col) {
            const celda = tablero[fila][col];
            if (!celda || celda.tipo !== 'normal') return [];

            let matches = [];
            let color;

            // Determinar el color base para la comparaci√≥n
            if (celda.especial && celda.especial !== TIPOS_ESPECIALES.ARCOIRIS) {
                color = obtenerColorDeEspecial(celda.especial);
                if (!color) return []; // Si no podemos determinar el color, no hacer match
            } else if (celda.especial === TIPOS_ESPECIALES.ARCOIRIS) {
                return []; // Los arco√≠ris no forman matches normales
            } else {
                color = celda.color;
            }

            // Funci√≥n auxiliar para obtener color de una celda
            function obtenerColorCelda(c) {
                if (!c || c.tipo !== 'normal') return null;
                if (c.especial === TIPOS_ESPECIALES.ARCOIRIS) return null;
                if (c.especial && c.especial !== TIPOS_ESPECIALES.ARCOIRIS) {
                    return obtenerColorDeEspecial(c.especial);
                }
                return c.color;
            }

            // Buscar horizontal
            let horizontal = [{ fila, col }];

            // Izquierda
            for (let c = col - 1; c >= 0; c--) {
                const colorActual = obtenerColorCelda(tablero[fila][c]);
                if (colorActual === color) {
                    horizontal.unshift({ fila, col: c });
                } else {
                    break;
                }
            }

            // Derecha
            for (let c = col + 1; c < COLUMNAS; c++) {
                const colorActual = obtenerColorCelda(tablero[fila][c]);
                if (colorActual === color) {
                    horizontal.push({ fila, col: c });
                } else {
                    break;
                }
            }

            if (horizontal.length >= 3) {
                matches = matches.concat(horizontal);
            }

            // Buscar vertical
            let vertical = [{ fila, col }];

            // Arriba
            for (let f = fila - 1; f >= 0; f--) {
                const colorActual = obtenerColorCelda(tablero[f][col]);
                if (colorActual === color) {
                    vertical.unshift({ fila: f, col });
                } else {
                    break;
                }
            }

            // Abajo
            for (let f = fila + 1; f < FILAS; f++) {
                const colorActual = obtenerColorCelda(tablero[f][col]);
                if (colorActual === color) {
                    vertical.push({ fila: f, col });
                } else {
                    break;
                }
            }

            if (vertical.length >= 3) {
                matches = matches.concat(vertical);
            }

            // Remover duplicados
            const uniqueMatches = [];
            matches.forEach(match => {
                if (!uniqueMatches.some(m => m.fila === match.fila && m.col === match.col)) {
                    uniqueMatches.push(match);
                }
            });

            return uniqueMatches;
        }

        function encontrarTodosLosMatches() {
            let todosLosMatches = [];

            for (let fila = 0; fila < FILAS; fila++) {
                for (let col = 0; col < COLUMNAS; col++) {
                    const celda = tablero[fila][col];
                    // Solo buscar matches en corazones normales (sin especial) o que ya exist√≠an antes
                    if (celda && celda.tipo === 'normal' && celda.especial !== TIPOS_ESPECIALES.ARCOIRIS) {
                        const matches = encontrarMatches(fila, col);
                        matches.forEach(match => {
                            if (!todosLosMatches.some(m => m.fila === match.fila && m.col === match.col)) {
                                todosLosMatches.push(match);
                            }
                        });
                    }
                }
            }

            return todosLosMatches;
        }

        function procesarMatches() {
            animando = true;

            setTimeout(() => {
                let matches = encontrarTodosLosMatches();

                if (matches.length > 0) {
                    let efectosActivados = false;
                    if (!suprimirEfectosUnaVez) {
                        efectosActivados = activarEfectosEspecialesEnMatches(matches);
                    } else {
                        suprimirEfectosUnaVez = false;
                    }

                    if (!efectosActivados) {
                        crearEfectosEspeciales(matches);
                        matches.forEach(m => marcarParaEliminar(m.fila, m.col));
                    }

                    romperObstaculosAdyacentes(matches);
                    resolverActivacionesYEliminaciones(); // <--- clave
                    actualizarUI();

                    setTimeout(() => {
                        // limpiar "recienCreado" tras primer pase
                        for (let fila = 0; fila < FILAS; fila++) {
                            for (let col = 0; col < COLUMNAS; col++) {
                                const celda = tablero[fila][col];
                                if (celda && celda.recienCreado) delete celda.recienCreado;
                            }
                        }
                        procesarMatches();
                    }, 300);
                } else {
                    animando = false;
                    verificarObjetivosEspeciales();
                    verificarEstadoJuego();
                }
            }, 200);
        }

        function activarEfectosEspecialesEnMatches(matches) {
            let efectosActivados = false;

            for (const match of matches) {
                const celda = tablero[match.fila][match.col];
                if (celda && celda.especial && !celda.recienCreado) {

                    if (esRayadoH(celda)) {
                        for (let c = 0; c < COLUMNAS; c++) marcarParaEliminar(match.fila, c);
                        efectosActivados = true; playTone(659, 0.3);
                    } else if (esRayadoV(celda)) {
                        for (let f = 0; f < FILAS; f++) marcarParaEliminar(f, match.col);
                        efectosActivados = true; playTone(659, 0.3);
                    } else if (celda.especial.startsWith('ENVUELTO_')) {
                        explosion3x3({ fila: match.fila, col: match.col });
                        efectosActivados = true; playTone(740, 0.3);
                    }
                    if (efectosActivados) break;
                }
            }
            return efectosActivados;
        }

        function crearEfectosEspeciales(matches) {
            const grupos = agruparMatchesPorLinea(matches);

            // Verificar si ya hay un coraz√≥n especial en el grupo
            const tieneEspecial = grupos.some(grupo =>
                grupo.some(match => tablero[match.fila][match.col].especial)
            );

            if (tieneEspecial) return; // No crear nuevo especial si ya hay uno

            grupos.forEach(grupo => {
                if (grupo.length === 4) {
                    const pos = grupo[Math.floor(grupo.length / 2)];
                    const color = tablero[pos.fila][pos.col].color;
                    const orient = (ultimaDireccionIntercambio === 'vertical') ? 'V' : 'H';
                    setTimeout(() => {
                        if (tablero[pos.fila][pos.col]) {
                            tablero[pos.fila][pos.col] = {
                                tipo: 'normal',
                                color,
                                especial: `RAYADO_${orient}_${color}`,
                                recienCreado: true
                            };
                        }
                    }, 250);
                } else if (grupo.length === 5) {
                    // Crear coraz√≥n arco√≠ris
                    const pos = grupo[Math.floor(grupo.length / 2)];
                    setTimeout(() => {
                        if (tablero[pos.fila][pos.col]) {
                            tablero[pos.fila][pos.col] = {
                                tipo: 'normal',
                                especial: TIPOS_ESPECIALES.ARCOIRIS,
                                recienCreado: true // Marcar como reci√©n creado
                            };
                        }
                    }, 250);
                    //mostrarMensaje('Corazon Arcoiris!');
                    playTone(988, 0.3);
                }
            });

            // Detectar patrones L and T para coraz√≥n envuelto
            detectarPatronesLT(matches);
        }

        function detectarPatronesLT(matches) {
            // Buscar exactamente patrones L con 5 corazones
            const gruposL = [];

            matches.forEach(match => {
                // Contar corazones en fila y columna desde este punto
                const enFila = matches.filter(m => m.fila === match.fila).length;
                const enColumna = matches.filter(m => m.col === match.col).length;

                // Si hay exactamente 3 en fila y 3 en columna (el central cuenta para ambos = 5 total)
                if (enFila === 3 && enColumna === 3) {
                    const color = tablero[match.fila][match.col].color;
                    setTimeout(() => {
                        if (tablero[match.fila][match.col]) {
                            tablero[match.fila][match.col] = {
                                tipo: 'normal',
                                color: color,
                                especial: `ENVUELTO_${color}`,
                                recienCreado: true
                            };
                        }
                    }, 250);
                    //mostrarMensaje('¬°Coraz√≥n Envuelto!');
                    return;
                }
            });
        }

        function agruparMatchesPorLinea(matches) {
            const grupos = [];
            const procesados = new Set();

            matches.forEach(match => {
                const key = `${match.fila}-${match.col}`;
                if (procesados.has(key)) return;

                // Buscar grupo horizontal
                let grupoH = matches.filter(m =>
                    m.fila === match.fila &&
                    Math.abs(m.col - match.col) <= 4
                ).sort((a, b) => a.col - b.col);

                if (grupoH.length >= 3) {
                    grupos.push(grupoH);
                    grupoH.forEach(m => procesados.add(`${m.fila}-${m.col}`));
                }

                // Buscar grupo vertical si no fue procesado
                if (!procesados.has(key)) {
                    let grupoV = matches.filter(m =>
                        m.col === match.col &&
                        Math.abs(m.fila - match.fila) <= 4 &&
                        !procesados.has(`${m.fila}-${m.col}`)
                    ).sort((a, b) => a.fila - b.fila);

                    if (grupoV.length >= 3) {
                        grupos.push(grupoV);
                        grupoV.forEach(m => procesados.add(`${m.fila}-${m.col}`));
                    }
                }
            });

            return grupos;
        }

        function romperObstaculosAdyacentes(matches) {
            matches.forEach(match => {
                const direcciones = [[-1, 0], [1, 0], [0, -1], [0, 1]];

                direcciones.forEach(([df, dc]) => {
                    const nuevaFila = match.fila + df;
                    const nuevaCol = match.col + dc;

                    if (nuevaFila >= 0 && nuevaFila < FILAS && nuevaCol >= 0 && nuevaCol < COLUMNAS) {
                        const celda = tablero[nuevaFila][nuevaCol];
                        if (celda && celda.tipo === 'obstaculo' && celda.elemento === ELEMENTOS.PIEDRA) {
                            // Romper piedra
                            tablero[nuevaFila][nuevaCol] = { tipo: 'normal', color: elegirAleatorio(CORAZONES_BASICOS) };
                            crearParticulas(nuevaFila, nuevaCol);
                        }
                    }
                });
            });
        }

        function verificarObjetivosEspeciales() {
            const config = NIVELES_CONFIG[nivel - 1];

            if (config.objetivo === 'besos') {
                // Verificar si los besos llegaron al fondo
                for (let col = 0; col < COLUMNAS; col++) {
                    const celda = tablero[FILAS - 1][col];
                    if (celda && celda.tipo === 'objetivo' && celda.elemento === ELEMENTOS.BESO) {
                        besosEntregados++;
                        tablero[FILAS - 1][col] = { tipo: 'normal', color: elegirAleatorio(CORAZONES_BASICOS) };
                        mostrarMensaje(`Beso entregado! ${besosEntregados}/${config.valor}`);
                    }
                }
            } else if (config.objetivo === 'osos') {
                // Verificar osos adyacentes del mismo tipo
                for (let fila = 0; fila < FILAS; fila++) {
                    for (let col = 0; col < COLUMNAS; col++) {
                        const celda = tablero[fila][col];
                        if (celda && celda.tipo === 'objetivo' && celda.elemento === ELEMENTOS.OSO) {
                            verificarEmparejamientoOsos(fila, col, celda.pareja);
                        }
                    }
                }
            }
        }

        function verificarEmparejamientoOsos(fila, col, tipoPareja) {
            const direcciones = [[-1, 0], [1, 0], [0, -1], [0, 1]];

            direcciones.forEach(([df, dc]) => {
                const nuevaFila = fila + df;
                const nuevaCol = col + dc;

                if (nuevaFila >= 0 && nuevaFila < FILAS && nuevaCol >= 0 && nuevaCol < COLUMNAS) {
                    const celda = tablero[nuevaFila][nuevaCol];
                    if (celda && celda.tipo === 'objetivo' &&
                        celda.elemento === ELEMENTOS.OSO && celda.pareja === tipoPareja) {

                        // Emparejar osos
                        ososEmparejados++;
                        tablero[fila][col] = { tipo: 'normal', color: elegirAleatorio(CORAZONES_BASICOS) };
                        tablero[nuevaFila][nuevaCol] = { tipo: 'normal', color: elegirAleatorio(CORAZONES_BASICOS) };

                        const config = NIVELES_CONFIG[nivel - 1];
                        mostrarMensaje(`Osos emparejados! ${ososEmparejados}/${config.valor}`);

                        crearParticulas(fila, col);
                        crearParticulas(nuevaFila, nuevaCol);

                        return;
                    }
                }
            });
        }

        /*
        // Activaciones especiales
        function activarArcoiris(colorObjetivo) {
            for (let fila = 0; fila < FILAS; fila++) {
                for (let col = 0; col < COLUMNAS; col++) {
                    const celda = tablero[fila][col];
                    if (celda && celda.tipo === 'normal' && celda.color === colorObjetivo) {
                        crearParticulas(fila, col);
                        tablero[fila][col] = null;
                        puntaje += 200;
                    }
                }
            }
        }

        function activarCombinaci√≥nEspecial(pos1, pos2) {
            // Destruir fila y columna completas
            for (let i = 0; i < COLUMNAS; i++) {
                if (tablero[pos1.fila][i]) {
                    crearParticulas(pos1.fila, i);
                    tablero[pos1.fila][i] = null;
                    puntaje += 150;
                }
            }

            for (let i = 0; i < FILAS; i++) {
                if (tablero[i][pos1.col]) {
                    crearParticulas(i, pos1.col);
                    tablero[i][pos1.col] = null;
                    puntaje += 150;
                }
            }
        }

        function activarGranExplosion(pos1, pos2) {
            const centroFila = Math.floor((pos1.fila + pos2.fila) / 2);
            const centroCol = Math.floor((pos1.col + pos2.col) / 2);

            for (let df = -3; df <= 3; df++) {
                for (let dc = -3; dc <= 3; dc++) {
                    const fila = centroFila + df;
                    const col = centroCol + dc;

                    if (fila >= 0 && fila < FILAS && col >= 0 && col < COLUMNAS) {
                        if (tablero[fila][col]) {
                            crearParticulas(fila, col);
                            tablero[fila][col] = null;
                            puntaje += 100;
                        }
                    }
                }
            }
        }*/

        function limpiarTableroCompleto() {
            for (let f = 0; f < FILAS; f++) for (let c = 0; c < COLUMNAS; c++) marcarParaEliminar(f, c, 300);
            crearEfectoDestelloMultiple();
        }

        // Gravedad y llenado
        function aplicarGravedad() {
            for (let col = 0; col < COLUMNAS; col++) {
                let vacios = 0;

                for (let fila = FILAS - 1; fila >= 0; fila--) {
                    if (tablero[fila][col] === null) {
                        vacios++;
                    } else if (vacios > 0) {
                        tablero[fila + vacios][col] = tablero[fila][col];
                        tablero[fila][col] = null;
                    }
                }
            }
        }

        function llenarEspaciosVacios() {
            for (let col = 0; col < COLUMNAS; col++) {
                for (let fila = 0; fila < FILAS; fila++) {
                    if (tablero[fila][col] === null) {
                        tablero[fila][col] = { tipo: 'normal', color: elegirAleatorio(CORAZONES_BASICOS) };
                    }
                }
            }
        }

        // Sistema de part√≠culas
        function crearParticulas(fila, col) {
            const x = MARGEN_X + col * TAMA√ëO_CELDA + TAMA√ëO_CELDA / 2;
            const y = MARGEN_Y + fila * TAMA√ëO_CELDA + TAMA√ëO_CELDA / 2;

            for (let i = 0; i < 8; i++) {
                particulas.push({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    radio: Math.random() * 3 + 2, // Part√≠culas m√°s grandes
                    color: '#ff6b9d',
                    vida: 30 // Vida m√°s larga
                });
            }
        }

        function actualizarParticulas() {
            for (let i = particulas.length - 1; i >= 0; i--) {
                const p = particulas[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.vida--;

                if (p.vida <= 0) {
                    particulas.splice(i, 1);
                }
            }
        }

        // Nuevos efectos visuales
        function crearEfectoDestelloFila(fila) {
            const x = MARGEN_X;
            const y = MARGEN_Y + fila * TAMA√ëO_CELDA;
            const ancho = COLUMNAS * TAMA√ëO_CELDA;
            const alto = TAMA√ëO_CELDA;

            crearEfectoDestello(x, y, ancho, alto);
        }

        function crearEfectoDestelloColumna(col) {
            const x = MARGEN_X + col * TAMA√ëO_CELDA;
            const y = MARGEN_Y;
            const ancho = TAMA√ëO_CELDA;
            const alto = FILAS * TAMA√ëO_CELDA;

            crearEfectoDestello(x, y, ancho, alto);
        }

        function crearEfectoDestelloArea(fila, col, tama√±o) {
            const radio = Math.floor(tama√±o / 2);
            const x = MARGEN_X + (col - radio) * TAMA√ëO_CELDA;
            const y = MARGEN_Y + (fila - radio) * TAMA√ëO_CELDA;
            const ancho = tama√±o * TAMA√ëO_CELDA;
            const alto = tama√±o * TAMA√ëO_CELDA;

            crearEfectoDestello(x, y, ancho, alto);
        }

        function crearEfectoDestelloMultiple() {
            // Crear destello para todo el tablero
            const x = MARGEN_X;
            const y = MARGEN_Y;
            const ancho = COLUMNAS * TAMA√ëO_CELDA;
            const alto = FILAS * TAMA√ëO_CELDA;

            crearEfectoDestello(x, y, ancho, alto);
        }

        function crearEfectoDestello(x, y, ancho, alto) {
            const destello = document.createElement('div');
            destello.className = 'efecto-destello';

            // Posicionar y dimensionar el destello
            destello.style.left = `${desplazamientoX + x * escala}px`;
            destello.style.top = `${desplazamientoY + y * escala}px`;
            destello.style.width = `${ancho * escala}px`;
            destello.style.height = `${alto * escala}px`;

            document.getElementById('contenedor').appendChild(destello);

            // Eliminar el elemento despu√©s de la animaci√≥n
            setTimeout(() => {
                if (destello.parentNode) {
                    destello.parentNode.removeChild(destello);
                }
            }, 500);
        }

        // UI y estado del juego
        function actualizarUI() {
            const config = NIVELES_CONFIG[nivel - 1];
            let objetivoTexto = '';

            if (config.objetivo === 'puntuacion') {
                objetivoTexto = `Objetivo: ${puntaje}/${config.valor}`;
            } else if (config.objetivo === 'besos') {
                objetivoTexto = `Besos: ${besosEntregados}/${config.valor}`;
            } else if (config.objetivo === 'osos') {
                objetivoTexto = `Osos: ${ososEmparejados}/${config.valor}`;
            }

            IUPuntaje.textContent = `Nivel: ${nivel} ‚Ä¢ ${objetivoTexto} ‚Ä¢ Movimientos: ${movimientos}`;
            IUVidas.textContent = `Vidas: ${vidas}`;
        }

        function verificarEstadoJuego() {
            const config = NIVELES_CONFIG[nivel - 1];
            let objetivoCompleto = false;

            if (config.objetivo === 'puntuacion') {
                objetivoCompleto = puntaje >= config.valor;
            } else if (config.objetivo === 'besos') {
                objetivoCompleto = besosEntregados >= config.valor;
            } else if (config.objetivo === 'osos') {
                objetivoCompleto = ososEmparejados >= config.valor;
            }

            if (objetivoCompleto) {
                mostrarSuperposicion('Nivel Completado!', '¬°Impresionante!');
            } else if (movimientos <= 0) {
                vidas--;
                mostrarSuperposicion('Nivel Fallido', 'Int√©ntalo de nuevo ‚ô•');
            }
        }

        function mostrarSuperposicion(titulo, frase) {
            document.getElementById('tituloSuperposicion').textContent = titulo;
            document.getElementById('nivelActual').textContent = nivel;
            document.getElementById('puntajeActual').textContent = puntaje;

            const config = NIVELES_CONFIG[nivel - 1];
            let objetivoTexto = '';
            if (config.objetivo === 'puntuacion') {
                objetivoTexto = `Alcanzar ${config.valor} puntos`;
            } else if (config.objetivo === 'besos') {
                objetivoTexto = `Entregar ${config.valor} besos`;
            } else if (config.objetivo === 'osos') {
                objetivoTexto = `Emparejar ${config.valor} osos`;
            }

            document.getElementById('objetivoTexto').textContent = objetivoTexto;
            document.getElementById('fraseFinal').textContent = frase;
            superposicion.hidden = false;
        }

        // Funciones de control
        function iniciarJuego() {
            pantallaInicio.hidden = true;
            juegoIniciado = true;
            setupAudio();
            // arrancar m√∫sica
            musicaFondo.volume = 0.25;
            musicaFondo.play().catch(() => { /* ignorar bloqueo si ocurre */ });
            document.getElementById('btnAudio').textContent = 'üîä M√∫sica';
            crearTablero();
            actualizarUI();
            buclePrincipal();
            resetBoostersNuevaPartida();
        }

        function continuarJuego() {
            superposicion.hidden = true;

            if (vidas <= 0) {
                // Game over - reiniciar
                vidas = 5;
                nivel = 1;
                puntaje = 0;
                resetBoostersNuevaPartida();
                crearTablero();
            } else {
                const config = NIVELES_CONFIG[nivel - 1];
                let objetivoCompleto = false;

                if (config.objetivo === 'puntuacion') {
                    objetivoCompleto = puntaje >= config.valor;
                } else if (config.objetivo === 'besos') {
                    objetivoCompleto = besosEntregados >= config.valor;
                } else if (config.objetivo === 'osos') {
                    objetivoCompleto = ososEmparejados >= config.valor;
                }

                if (objetivoCompleto) {
                    // Siguiente nivel
                    if (nivel < 10) {
                        nivel++;
                        puntaje = 0;
                        crearTablero();
                    } else {
                        // Juego completado
                        mostrarMensaje('Juego Completado! Felicidades!');
                        vidas = 5;
                        nivel = 1;
                        puntaje = 0;
                        resetBoostersNuevaPartida();
                        crearTablero();
                    }
                } else {
                    // Reintentar nivel
                    crearTablero();
                }
            }

            actualizarUI();
        }

        function reiniciarNivel() {
            if (animando) return;
            crearTablero();
            puntaje = 0;
            actualizarUI();
        }

        // Renderizado
        function dibujarCelda(fila, col, x, y) {
            const celda = tablero[fila][col];
            if (!celda) return;

            const centroX = x + TAMA√ëO_CELDA / 2;
            const centroY = y + TAMA√ëO_CELDA / 2;

            if (celda.tipo === 'normal') {
                // Dibujar imagen seg√∫n el tipo de coraz√≥n
                let imagen;

                if (celda.especial && (celda.especial.startsWith('RAYADO_H_') || celda.especial.startsWith('RAYADO_V_') || celda.especial.startsWith('RAYADO_'))) {
                    const colorEspecial = obtenerColorDeEspecial(celda.especial);
                    if (esRayadoV(celda)) {
                        imagen = imagenesCargadas[`RAYADO_V_${colorEspecial}`];
                    } else {
                        // Horizontal por defecto (+ compat con RAYADO_COLOR)
                        imagen = imagenesCargadas[`RAYADO_H_${colorEspecial}`] || imagenesCargadas[`RAYADO_${colorEspecial}`];
                    }
                } else if (celda.especial && celda.especial.startsWith('ENVUELTO_')) {
                    const colorEspecial = celda.especial.replace('ENVUELTO_', '');
                    imagen = imagenesCargadas[`ENVUELTO_${colorEspecial}`];
                } else if (celda.especial === TIPOS_ESPECIALES.ARCOIRIS) {
                    imagen = imagenesCargadas.ARCOIRIS;
                } else {
                    imagen = imagenesCargadas[celda.color];
                }

                if (imagen) {
                    contexto.drawImage(imagen, x + 5, y + 5, TAMA√ëO_CELDA - 10, TAMA√ëO_CELDA - 10);
                } else {
                    // Fallback a colores si las im√°genes no est√°n cargadas
                    const coloresFallback = {
                        ROSADO: '#ff6b9d',
                        MORADO: '#9b59b6',
                        AMARILLO: '#f1c40f',
                        NARANJA: '#e67e22',
                        VERDE: '#2ecc71',
                        CELESTE: '#3498db'
                    };
                    contexto.fillStyle = coloresFallback[celda.color] || '#ff6b9d';
                    contexto.fillRect(x + 10, y + 10, TAMA√ëO_CELDA - 20, TAMA√ëO_CELDA - 20);
                }
            } else if (celda.tipo === 'obstaculo') {
                if (celda.elemento === ELEMENTOS.PIEDRA) {
                    if (imagenesCargadas.PIEDRA) {
                        contexto.drawImage(imagenesCargadas.PIEDRA, x + 5, y + 5, TAMA√ëO_CELDA - 10, TAMA√ëO_CELDA - 10);
                    } else {
                        contexto.fillStyle = '#7f8c8d';
                        contexto.fillRect(x + 5, y + 5, TAMA√ëO_CELDA - 10, TAMA√ëO_CELDA - 10);
                    }
                } else if (celda.elemento === ELEMENTOS.NUBE) {
                    if (imagenesCargadas.NUBE) {
                        contexto.drawImage(imagenesCargadas.NUBE, x, y, TAMA√ëO_CELDA, TAMA√ëO_CELDA);
                    } else {
                        contexto.fillStyle = 'rgba(128, 128, 128, 0.7)';
                        contexto.fillRect(x, y, TAMA√ëO_CELDA, TAMA√ëO_CELDA);
                    }
                }
            } else if (celda.tipo === 'objetivo') {
                if (celda.elemento === ELEMENTOS.BESO) {
                    if (imagenesCargadas.BESO) {
                        contexto.drawImage(imagenesCargadas.BESO, centroX - 15, centroY - 15, 30, 30);
                    } else {
                        contexto.fillStyle = '#e74c3c';
                        contexto.beginPath();
                        contexto.arc(centroX, centroY, 15, 0, Math.PI * 2);
                        contexto.fill();
                    }
                } else if (celda.elemento === ELEMENTOS.OSO) {
                    if (imagenesCargadas.OSO) {
                        contexto.drawImage(imagenesCargadas.OSO, centroX - 12, centroY - 12, 24, 24);
                        contexto.fillStyle = 'white';
                        contexto.font = '12px Arial';
                        contexto.textAlign = 'center';
                        contexto.textBaseline = 'middle';
                        contexto.fillText(celda.pareja.toString(), centroX, centroY + 8);
                    } else {
                        const coloresOso = ['#8B4513', '#CD853F', '#A0522D'];
                        contexto.fillStyle = coloresOso[celda.pareja - 1] || '#8B4513';
                        contexto.fillRect(centroX - 12, centroY - 12, 24, 24);
                        contexto.fillStyle = 'white';
                        contexto.font = '12px Arial';
                        contexto.textAlign = 'center';
                        contexto.textBaseline = 'middle';
                        contexto.fillText(celda.pareja.toString(), centroX, centroY);
                    }
                }
            }

            // Resaltar selecci√≥n
            const isNormalSelected =
                seleccionado && seleccionado.fila === fila && seleccionado.col === col;

            const isHandSelected =
                boosterActivo === BOOSTERS.MANO &&
                seleccionBooster &&
                seleccionBooster.fila === fila &&
                seleccionBooster.col === col;

            if (isNormalSelected || isHandSelected) {
                contexto.strokeStyle = '#ff6b9d'; // mismo estilo que la selecci√≥n normal
                contexto.lineWidth = 3;
                contexto.strokeRect(x + 2, y + 2, TAMA√ëO_CELDA - 4, TAMA√ëO_CELDA - 4);
            }
        }

        // Bucle principal
        function buclePrincipal() {
            establecerTransformacionMundo();

            // Limpiar canvas
            contexto.clearRect(0, 0, MUNDO_ANCHO, MUNDO_ALTO);

            // Dibujar fondo con gradiente suave
            const gradiente = contexto.createLinearGradient(
                0, 0,
                MUNDO_ANCHO, MUNDO_ALTO
            );
            gradiente.addColorStop(0, '#1a1625');
            gradiente.addColorStop(0.5, '#151022');
            gradiente.addColorStop(1, '#0f0f14');
            contexto.fillStyle = gradiente;
            contexto.fillRect(0, 0, MUNDO_ANCHO, MUNDO_ALTO);

            // Dibujar patr√≥n de estrellas sutiles en el fondo
            contexto.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 50; i++) {
                const starX = Math.random() * MUNDO_ANCHO;
                const starY = Math.random() * MUNDO_ALTO;
                const size = Math.random() * 1.5;
                contexto.beginPath();
                contexto.arc(starX, starY, size, 0, Math.PI * 2);
                contexto.fill();
            }

            // Dibujar tablero
            for (let fila = 0; fila < FILAS; fila++) {
                for (let col = 0; col < COLUMNAS; col++) {
                    const x = MARGEN_X + col * TAMA√ëO_CELDA;
                    const y = MARGEN_Y + fila * TAMA√ëO_CELDA;
                    dibujarCelda(fila, col, x, y);
                }
            }

            // Actualizar y dibujar part√≠culas
            actualizarParticulas();
            particulas.forEach(p => {
                contexto.globalAlpha = p.vida / 30;
                contexto.fillStyle = p.color;
                contexto.beginPath();
                contexto.arc(p.x, p.y, p.radio, 0, Math.PI * 2);
                contexto.fill();
                contexto.globalAlpha = 1;
            });

            requestAnimationFrame(buclePrincipal);
        }

        // Inicializaci√≥n
        function inicializar() {
            redimensionar();
            window.addEventListener('resize', redimensionar);
            configurarEventos();
            cargarImagenes();
            actualizarUI();
            aplicarIconosBoosters();
            actualizarUIBoosters();
        }

        document.getElementById('btnSalir')?.addEventListener('click', () => {
            window.location.href = 'index.html';
        });

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', inicializar);
        } else {
            inicializar();
        }
    </script>
</body>

</html>